<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: functional-programming | Francis Stokes: Blog]]></title>
  <link href="http://francisrstokes.github.io/blog/blog/categories/functional-programming/atom.xml" rel="self"/>
  <link href="http://francisrstokes.github.io/blog/"/>
  <updated>2019-01-12T10:55:39+01:00</updated>
  <id>http://francisrstokes.github.io/blog/</id>
  <author>
    <name><![CDATA[Francis Stokes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploring The Peano Axioms With Algebraic Data Types]]></title>
    <link href="http://francisrstokes.github.io/blog/blog/2019/01/12/exploring-the-peano-axioms-with-algebraic-data-types/"/>
    <updated>2019-01-12T09:00:00+01:00</updated>
    <id>http://francisrstokes.github.io/blog/blog/2019/01/12/exploring-the-peano-axioms-with-algebraic-data-types</id>
    <content type="html"><![CDATA[<p>The <em>Peano Axioms</em> are <a href="https://en.wikipedia.org/wiki/Peano_axioms" _target="blank">8 simple rules</a> that can define the natural number system. What are the natural numbers? They&rsquo;re are just the numbers <em>0, 1, 2, 3, &hellip;</em> and so on, up to infinity.</p>

<p>This system is interesting because in mathematics, you need to be rigorous; You can&rsquo;t go around saying numbers (or any mathematical object) <em>just are</em>, you have be able to really describe what you mean when you talk about <em>zeroness</em> or <em>oneness</em>.</p>

<h2>The Axioms</h2>

<p>The Peano Axioms describe a <em>system</em> with two elements: An <em>object</em> <code>0</code>, and a <em>function</em> <code>S</code>. I&rsquo;m using these words object and function quite loosely. As you will see below, <code>0</code> could actually be any symbol you choose, and the function <code>S</code> (known as the successor function) also essentially acts as just a symbol - that is to say, it is not necessary to define <code>S</code> function further than what is shown below.</p>

<p>These are the axioms as stated on wikipedia:</p>

<ol>
<li><code>0</code> is a natural number</li>
<li>For every natural number <code>x</code>, <code>x = x</code> (reflexivity)</li>
<li>For all natural numbers <code>x</code> and <code>y</code>, if <code>x = y</code>, then <code>y = x</code> (symmetry)</li>
<li>For all natural numbers <code>x</code>, <code>y</code> and <code>z</code>, if <code>x = y</code> and <code>y = z</code>, then <code>x = z</code> (transitivity)</li>
<li>For all <code>a</code> and <code>b</code>, if <code>b</code> is a natural number and <code>a = b</code>, then <code>a</code> is also a natural number (closure under equality)</li>
<li>For every natural number <code>n</code>, <code>S(n)</code> is a natural number</li>
<li>For all natural numbers <code>m</code> and <code>n</code>, <code>m = n</code> <strong>if and only if</strong> <code>S(m) = S(n)</code> (injection)</li>
<li>For every natural number <code>n</code>, <code>S(n) = 0</code> is <strong>false</strong>. That is, there is no natural number whose successor is <code>0</code></li>
</ol>


<p>What these axioms state is that we have an initial number <code>0</code>, which is not the successor of any other number (i.e. it is the smallest), and that we can create new numbers by applying a successor function to any number. So there is a successor of <code>0</code> called <code>S(0)</code>, and a successor to that called <code>S(S(0))</code>, and so on.</p>

<p>Practically speaking, you can read a Peano encoded natural number as simply being the number of <code>S</code>s it has. So <code>S(0)</code> is <code>1</code>, <code>S(S(0))</code> is <code>2</code>, and so on.</p>

<p>Here&rsquo;s a table of the first few Peano numbers</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> <em>N</em> </th>
<th style="text-align:center;"> <em>Peano</em> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> 0      </td>
<td style="text-align:center;"> 0            </td>
</tr>
<tr>
<td style="text-align:center;"> 1      </td>
<td style="text-align:center;"> S(0)         </td>
</tr>
<tr>
<td style="text-align:center;"> 2      </td>
<td style="text-align:center;"> S(S(0))      </td>
</tr>
<tr>
<td style="text-align:center;"> 3      </td>
<td style="text-align:center;"> S(S(S(0)))   </td>
</tr>
<tr>
<td style="text-align:center;"> 4      </td>
<td style="text-align:center;"> S(S(S(S(0))))</td>
</tr>
</tbody>
</table>


<h2>Algebraic Data Types</h2>

<p>We can represent this system in <em>types</em> by utilising something called an <a href="https://en.wikipedia.org/wiki/Algebraic_data_type" target="_blank">Algebraic Data Type</a>. An <em>Algebraic type</em> is either:</p>

<ul>
<li>A <strong>product</strong> type, like a <a href="https://en.wikipedia.org/wiki/Record_(computer_science)" target="_blank">record/object/struct</a> or a <a href="https://en.wikipedia.org/wiki/Tuple" target="_blank">tuple</a></li>
<li>A <strong>sum</strong> type, which is a <em>union</em> of other types</li>
</ul>


<p>For this article we will focus on the <strong>sum type</strong>. There are many common sum types that we use every day. <code>Boolean</code> is a sum type of the types <code>True</code> and <code>False</code>. In Haskell it might be defined as</p>

<pre><code class="haskell">data Boolean = True | False
</code></pre>

<p>In JavaScript, we can use a library like <code>daggy</code> or <code>algebraic-types</code> to create a sum type. For these examples I will use <code>algebraic-types</code> because it provides a mechanism to properly define recursive types.</p>

<pre><code class="javascript">const {createUnionType} = require('algebraic-types');

const Boolean = createUnionType('Boolean', {
  True: [],
  False: []
});
</code></pre>

<p><code>True</code> and <code>False</code> are both types that belong to the type <code>Boolean</code>. This is a simple but powerful concept, because it implies that meaning can be <em>encoded</em> directly on the type level. To illustrate this further, let&rsquo;s take a breif look at a slightly more complex sum type, <code>Maybe</code>, which encodes possible nothingness.</p>

<p>In Haskell:</p>

<pre><code class="haskell">data Maybe a = Just a | Nothing
</code></pre>

<p>In JavaScript:</p>

<pre><code class="javascript">const {createUnionType, variable} = require('algebraic-types');

const Maybe = createUnionType('Maybe', {
  Nothing: [],
  Just: [variable('a')]
});
</code></pre>

<p>This should be read <em>&ldquo;A <code>Maybe</code> of &lsquo;a&rsquo; is either <code>Just</code> &lsquo;a&rsquo; or it is <code>Nothing</code>&rdquo;</em>, where &lsquo;a&rsquo; can be <em>any</em> value. You never need to write a function or method that returns <code>null</code> to indicate no value because you can do it on the type level.</p>

<p>One more thing that we can do with sum types is define <em>recursive</em> structures. A binary tree is laughably trival to implement as a sum type:</p>

<p>In Haskell:</p>

<pre><code class="haskell">data BinaryTree a = Leaf a | Branch BinaryTree BinaryTree;
</code></pre>

<p>In JavaScript:</p>

<pre><code class="javascript">const {createUnionType, variable, recursive} = require('algebraic-types');

const BinaryTree = createUnionType('BinaryTree', {
  Leaf: [variable('a')],
  Branch: [recursive('left'), recursive('right')]
});
</code></pre>

<p>Which is to say a <code>BinaryTree</code> is either <code>Leaf</code> of some value &lsquo;a&rsquo;, or it&rsquo;s a <code>Branch</code> of two more <code>BinaryTree</code>s (both of which can be either a <code>Leaf</code> or a <code>Branch</code>).</p>

<h2>Back to Peano</h2>

<p>Now we have a basic understanding of sum types, we can apply the concepts of <em>encoding meaning</em> and <em>recursive definition</em> to creating a type for Peano Numbers. I will use JavaScript for the rest of the examples, but the translation to Haskell is trival.</p>

<pre><code class="javascript">const Peano = createUnionType('Peano', {
  O: [],
  S: [recursive('x')]
});
</code></pre>

<p>The <code>Peano</code> type is made of two types: <code>O</code>, which has no variables of its own, and <code>S</code>, which has one variable that must be another <code>Peano</code> type. The recursive definition ensures that we can only have <em>axiomatically</em> correct constructions:</p>

<pre><code class="javascript">const {S, O} = Peano;

// All the following are valid
const zero = O();
const one = S(zero);
const two = S(one);
const three = S(S(S(O())));

// But this is not
const invalid = S("hello");
// -&gt; Error: Variable x on constructor S must be a Peano
</code></pre>

<p>So just by creating this type, we have the first axiom down. The next three axioms are related to the properties of <em>equality</em> in this system. We can encode them by adding a method <code>eq</code> to prototype of the <code>Peano</code> constructor. Since methods are defined on the <code>Peano</code> type rather than the on the <em>child types</em> <code>S</code> or <code>O</code>, there must be a mechanism to check which type the <code>Peano</code> actually is inside a method. <code>algebraic-types</code> adds a method called <code>match</code> to every type you create with it, which can perform this operation (called pattern matching). We can use this to build a recursive definition for <code>eq</code>.</p>

<pre><code class="javascript">Peano.prototype.eq = function (y) {
  const x = this;

  return x.match({
    O: () =&gt; y.match({
      O: () =&gt; true,
      S: () =&gt; false
    }),
    S: innerX =&gt; y.match({
      O: () =&gt; false,
      S: innerY =&gt; innerX.eq(innerY)
    })
  });
}

const zero = O();
const one = S(zero);

const x = S(one);
const y = S(S(zero));
const z = S(S(O()));

// Reflexivity
x.eq(x); // -&gt; true

// Symmetry
x.eq(y); // -&gt; true
y.eq(x); // -&gt; true

// Transitivity
x.eq(y); // -&gt; true
y.eq(z); // -&gt; true
x.eq(z); // -&gt; true
</code></pre>

<p>The rest of the axioms fall out of either the type defintion itself, or the implementation of equality.</p>

<p>Let&rsquo;s break down the recursive definition for equality a little bit, as the same principle will be used to define more operations like addition and multiplication.</p>

<p>To compare if two <code>Peano</code>s, <code>x</code> and <code>y</code> are equal, we simply have to look at their types with <em>pattern-matching</em>. If <code>x</code> is a <code>O</code> and <code>y</code> is an <code>S</code> of <em>anything</em>, then they cannot be equal, but if <code>y</code> is also a <code>O</code> then we can say that they <em>are</em> equal. If both <code>x</code> and <code>y</code> are an <code>S</code> of something, then we must recursively call <code>eq</code> on their inner values. If they are indeed equal, this process will continue until both inner values reach <code>O</code>. If they are not equal, then one of the values will reach <code>O</code> while the other is an <code>S</code> of something, which we have already defined as non-equal.</p>

<h2>More operations</h2>

<h3>Addition</h3>

<p>Even though we can construct <code>Peano</code> numbers, and check if they are equal to each other, this can be described as neither particularly useful nor particularly interesting. What would be interesting is the ability to add one <code>Peano</code> to another, yielding a new <code>Peano</code>.</p>

<pre><code class="javascript">Peano.prototype.add = function (y) {
  const x = this;

  return x.match({
    O: () =&gt; y,
    S: innerX =&gt; S(y).add(innerX)
  });
};

// 2 + 3
S(S(O())).add(S(S(S(O()))));
// -&gt; S(S(S(S(S(O())))))
</code></pre>

<p>Adding <code>x</code> and <code>y</code> is another recursive operation. Since for any number we know that <code>y + 0 = y</code>, <em>pattern-matching</em> a <code>O</code> value for <code>x</code> means that we can just return the other value (even if that value was a zero itself). If the value of <code>x</code> is an <code>S</code> however, and we increase the other <code>y</code> by wrapping it in an <code>S</code>, and add that to the inner value of <code>x</code>, then the effect is to add one to <code>y</code> and minus one from <code>x</code>. <code>x</code> will eventually match <code>O</code> and the final value of <code>y</code> will be returned.</p>

<p>This is kind of like have two piles of blocks that you want to add. If you just move one block at a time from the first pile into the second pile until there are no blocks left in the first pile, then the second pile will <em>of course</em> contain the number of blocks in the second pile plus the number of blocks in the first.</p>

<h3>Subtraction</h3>

<p>A very similar trick can be used for subtraction, but first it&rsquo;s good to mention that subtraction in the Peano Axioms is not really <em>well defined</em>, since there are no negative numbers (axiom #8). For this reason we will say that an expression like <code>4 - 5</code> in our world will simply equal <code>0</code>, rather than <code>-1</code>.</p>

<p>Going back to the idea of two piles, if we remove one block from each pile until one of the piles is empty, then whatever is left on the other pile is the result of <code>(Pile #1) - (Pile #2)</code>. You can try it for yourself if you need some convincing.</p>

<pre><code class="javascript">Peano.prototype.sub = function (y) {
  const x = this;

  return x.match({
    O: () =&gt; y,
    S: innerX =&gt; y.match({
      O: =&gt; S(innerX),
      S: =&gt; innerX.sub(y)
    })
  });
};

// 3 - 2
S(S(S(O()))).sub(S(S(O())));
// -&gt; S(O())
</code></pre>

<p>Notice that we need to put <code>x</code> back into an <code>S</code> if <code>y</code> is a <code>O</code>, because otherwise we would be off by one.</p>

<h3>Multiplication</h3>

<p>Multiplication is just glorified addition, so we should be able to build it onto of the existing <code>add</code> method.</p>

<pre><code class="javascript">Peano.prototype.mul = function (y) {
  const x = this;

  return x.match({
    O: () =&gt; O(),
    S: innerX =&gt; y.match({
      O: () =&gt; O(),
      S: innerY =&gt; S(innerX).add(
        innerY.mul(S(innerX))
      )
    })
  });
};
</code></pre>

<p>Anything times <code>0</code> is always <code>0</code>, so in both those cases are easy. To multiply two numbers larger than zero we just keep adding <code>x</code>s while <code>y</code> is greater than <code>0</code>, unwrapping a level of <code>y</code> every time.</p>

<h2>Converting to and from Integers</h2>

<p>It could be useful (as far as this system is useful in a practical sense) to be able to convert <code>Peano</code> numbers to regular <code>Number</code>s, and to convert positive integers to <code>Peano</code> numbers. We can write a <code>toInteger</code> method like:</p>

<pre><code class="javascript">Peano.prototype.toInteger = function () {
  const x = this;
  return x.match({
    O: () =&gt; 0,
    S: innerX =&gt; 1 + innerX.toInteger()
  });
};

S(S(S(S(O())))).toInteger();
// -&gt; 4
</code></pre>

<p>Which is basically just a recursive operation that unfolds to something like <code>1 + 1 + 1 + 1 + ... + 0</code>.</p>

<p><code>fromInteger</code> can be a static method on the <code>Peano</code> object which works in the other direction, by recursively wrapping <code>n</code> layers of <code>S</code> around an <code>O</code>.</p>

<pre><code class="javascript">Peano.fromInteger = (n) =&gt; {
  const f = (total, n) =&gt; {
    if (n &gt; 0) {
      return f(S(total), n - 1);
    }
    return total;
  };

  return f(O(), n);
};

Peano.fromInt(5);
// -&gt; S(S(S(S(S(O())))))
</code></pre>

<p>This has the nice effect of not blowing up if we throw in a negative number - we&rsquo;d simply get <code>0</code> in those cases.</p>

<p>Now we can perform <em>advanced</em> calculations like</p>

<pre><code class="javascript">const three = S(S(S(O())));

Peano
  .fromInteger(50)
  .mul(three)
  .sub(S(three))
  .add(O())
  .toInteger();
// -&gt; 146
</code></pre>

<h2>Conclusion</h2>

<p>The Peano Axioms have fascinated me ever since I learned about them because they are a digestible piece of mathematics that is somehow apart from the rote concepts you learn while making your way through the education system. The system shines a subtle light on the real underpinnings of mathematics; the rigor of defining the properties of a mathematical object. At school you might be tricked into thinking that numbers <em>just are</em>, but really they are just one of many mathematical objects with different kinds of properties. If you&rsquo;re like me, and perhaps never knew about this side of math, you can check out the field of <a href="https://en.wikipedia.org/wiki/Abstract_algebra" target="_blank">Abstract Algebra</a>, that classifies objects and systems of this kind based on the properties they have.</p>

<p>But from a practical development perspective, as a number system, this isn&rsquo;t particularly useful in everyday life. That said, you might find some real value in <em>modeling with types</em>. It&rsquo;s a really powerful concept when applied correctly, especially when combined with functions that operate on types. You can discern a lot about a program by just looking at the <em>signatures</em> of such functions - what types do they take as parameters and what types do they return. If you&rsquo;ve read this article coming from the JavaScript world, I advise you to checkout Haskell (especially if you&rsquo;ve enjoyed the benefits of TypeScript). It takes programming with types to a fine art.</p>

<p><a href="https://twitter.com/fstokesman" target="_blank">If you&rsquo;ve found this article interesting, I&rsquo;d really love to hear from you about it! Send me tweet @fstokesman</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arcsecond: Parsing In JavaScript Made Easy]]></title>
    <link href="http://francisrstokes.github.io/blog/blog/2019/01/07/arcsecond-parsing-in-javascript-made-easy/"/>
    <updated>2019-01-07T14:20:18+01:00</updated>
    <id>http://francisrstokes.github.io/blog/blog/2019/01/07/arcsecond-parsing-in-javascript-made-easy</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/gandalf.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>I recently starting making a serious attempt at learning Haskell (anyone who has tried before will probably sympathise that it usually takes a couple of tries to crack it). Amongst the many cool things Haskell has to offer is an amazing parsing library that comes with the standard set of packages called <a href="https://wiki.haskell.org/Parsec"><strong>Parsec</strong></a><strong>,</strong> which lets you describe how to parse complex grammars in what essentially looks like natural language.</p>

<p>Here is how a CSV parser is implemented using Parsec. Don’t worry if you don’t understand all the syntax, the point is that the whole parser is specified in just four lines.</p>

<pre><code class="haskell">-- Taken from http://book.realworldhaskell.org/read/using-parsec.html

import Text.ParserCombinators.Parsec

csvFile = endBy line eol
line = sepBy cell (char ',')
cell = many (noneOf ",\n")
eol = char '\n'

parseCSV :: String -&gt; Either ParseError [[String]]
parseCSV input = parse csvFile "(unknown)" input
</code></pre>

<p>If you want to read more checkout <a href="http://book.realworldhaskell.org">http://book.realworldhaskell.org</a></p>

<p>This post is not about Haskell however, <a href="https://github.com/francisrstokes/arcsecond">but rather a library I wrote called <strong>arcsecond</strong> which is based on Parsec</a>, with the goal of bringing that same expressivity to JavaScript.</p>

<h3>Parser combinators</h3>

<p><strong>arcsecond</strong> is a parser combinator library, in which complex parsers can be built by composing simple parsers. The simplest parsers just match specific strings or characters:</p>

<pre><code class="javascript">
const { digit, letter, char, str, regex } = require('arcsecond');

// digit will parse any number 0-9
// letter will parse any letter a-z or A-Z

// char and str will parse specific sequences
const getA = char ('a');
const getHello = str ('hello');

// regex will parse any given regular expression
const getLowNumbers = regex (/^[0-4]+/);
</code></pre>

<p>These can then be combined together with the <em>combinators</em> in the library.</p>

<pre><code class="javascript">const { char, str, sequenceOf, choice } = require('arcsecond');

const worldOrMarsOrVenus = choice ([
  str ('world'),
  str ('mars'),
  str ('venus')
]);

const combinedParser = sequenceOf ([
  str ('hello'),
  char (' '),
  worldOrMarsOrVenus
]);
</code></pre>

<p>Then the new parsers can be used with text:</p>

<pre><code class="javascript">const { parse, char, str, sequenceOf, choice } = require('arcsecond');

// parse creates a function we can use for parsing text
const parseText = parse (combinedParser);

console.log(
  parseText ('hello world') 
)
// -&gt; [ 'hello', ' ', 'world' ]
</code></pre>

<h4>Combinators</h4>

<p>The combinators are where it gets cool. In <strong>arcsecond</strong> a combinator is a higher order parser, which takes one or more parsers as its input and gives back a new parser that <em>combines</em> those in some way. If you’ve used <em>higher order components</em> in react like <strong><em>connect</em></strong>, <strong><em>withRouter</em></strong>, or <strong><em>withStyles</em></strong>, then you’re already familiar with the idea.</p>

<p>As shown above, <strong><em>sequenceOf</em></strong> is a combinator that will parse text using each of the parsers in order, collecting their results into an array.</p>

<p><strong><em>choice</em></strong>, on the other hand, will try each of its parsers in order and use the first one that matches. The library contains more, like <strong><em>many</em></strong>, which takes a parser as an argument and matches as much as it can using that parser, collecting up the results in an array:</p>

<pre><code class="javascript">const { parse, many, choice, str } = require('arcsecond');

const animal = choice ([
  str ('dog'),
  str ('whale'),
  str ('bear'),
  str ('ant')
]);

const manyAnimals = many (animal);

// parse creates a function we can use for parsing text
const parseText = parse (manyAnimals);

console.log(
  parseText ('dogantwhaledogbear') 
)
// -&gt; [ 'dog', 'ant', 'whale', 'dog', 'bear' ]
</code></pre>

<p>You can use <strong><em>sepBy</em></strong> to create a parser that matches items separated by something matched by <em>another parser</em>.</p>

<pre><code class="javascript">const { parse, sepBy, choice, str, char } = require('arcsecond');

const animal = choice ([
  str ('dog'),
  str ('whale'),
  str ('bear'),
  str ('ant')
]);

const commaSeparated = sepBy (char (','));

const commaSeparatedAnimals = commaSeparated (animal);

// parse creates a function we can use for parsing text
const parseText = parse (commaSeparatedAnimals);

console.log(
  parseText ('dog,ant,whale,dog,bear') 
)
// -&gt; [ 'dog', 'ant', 'whale', 'dog', 'bear' ]
</code></pre>

<p><strong><em>between</em></strong> will let you match items that occur between <em>two other parsers</em>.</p>

<pre><code class="javascript">const { parse, between, sepBy, choice, str, char } = require('arcsecond');

const animal = choice ([
  str ('dog'),
  str ('whale'),
  str ('bear'),
  str ('ant')
]);

const betweenBrackets = between (char ('[')) (char (']'));
const commaSeparated = sepBy (char (','));

const commaSeparatedAnimals = commaSeparated (animal);
const arrayOfAnimals = betweenBrackets (commaSeparatedAnimals);

// parse creates a function we can use for parsing text
const parseText = parse (arrayOfAnimals);

console.log(
  parseText ('[dog,ant,whale,dog,bear]') 
)
// -&gt; [ 'dog', 'ant', 'whale', 'dog', 'bear' ]
</code></pre>

<h4>Curried Functions</h4>

<p><strong>arcsecond</strong> makes use of curried functions. If you don’t know what a curried function is, give my article “<a href="https://hackernoon.com/making-functional-programming-click-836d4715baf2">Making Functional Programming Click</a>” a read. If you really can’t be bothered right now, open that in another tab and read this executive summary.</p>

<p>A curried function is one that, if it takes more than one argument, it instead returns a new function that takes the next argument. It’s easier to see with some code:</p>

<pre><code class="javascript">// Normal function, just a single function taking both arguments and returning a result
function normalAdd(a, b) {
  return a + b; 
}

normalAdd(1, 2);
// -&gt; 3


// Curried function, a function that takes the first argument and then returns
// *another function*, which takes the next argument.
function curriedAdd(a) {
  return function(b) {
    return a + b; 
  }
}

curriedAdd(1)(2);
// -&gt; 3

// We can use curried functions to easily make new, more specific functions
const addOne = curriedAdd(1);

addOne(2);
// -&gt; 3
</code></pre>

<p>As you can see above, <strong><em>curriedAdd</em></strong> is first called with 1. Since it then returns a function, we can go ahead and call that with 2, which finally returns the actual result.</p>

<p>We can use <strong><em>curriedAdd</em></strong> to create a new function by calling it with just one argument and then assigning the result to a variable. As a language, JavaScript treats functions as a first class citizen, meaning they can be passed around and assigned to variables.</p>

<p>This principle lies at the heart of <strong>arcsecond,</strong> and every function in the library is defined this way. <strong><em>sepBy</em></strong> take two parsers — first a separator parser, and second a value parser. Because it is curried, it is easy to create a more specific combinator like <strong><em>commaSeparated</em></strong> by only supplying the first argument.</p>

<blockquote><p>If you’re not used to it, it will probably seem strange. But a good lesson to learn as a software developer is not to have knee-jerk bad reactions to things that you don’t immediately understand. There is usually a reason, and you’ll find a lot more value by discovering that reason rather than dismissing it.</p></blockquote>

<h3>Error Handling</h3>

<p>If you try to parse a string which is not correctly formatted you would expect to get some kind of error message. <strong>arcsecond</strong> uses a special data type called an <strong><em>Either</em></strong>, which is <em>either</em> a value or an error. It’s like a <strong><em>Promise</em></strong>, which can be either Rejected or Resolved, but without the implication of being asynchronous. In an <strong><em>Either</em></strong> however, the “resolved” type is called a <strong><em>Right</em></strong>, and the “rejected” type is called a <strong><em>Left</em></strong>.</p>

<p>The return type of <strong><em>parse</em></strong> is an Either. You can get at the value or error like this:</p>

<pre><code class="javascript">const { parse, sequenceOf, str, char } = require('arcsecond');

const parser = sequenceOf ([
  str ('hello'),
  char (' '),
  str ('world')
]);

const parseResult = parse(parser)('hello world');

// We can use the cata method, which is basically a switch/case but for types
parseResult.cata({
  Left: err =&gt; {
    // do something here with the error
  },
  Right: result =&gt; {
    // result -&gt; [ 'hello', ' ', 'world' ] 
  }
});
</code></pre>

<p>However this might not fit well into your codebase if you don’t have more functional code. For that reason there are two other options. The first is to convert the <strong><em>Either</em></strong> into a <strong><em>Promise:</em></strong></p>

<pre><code class="javascript">const { parse, sequenceOf, str, char, toPromise } = require('arcsecond');

const parser = sequenceOf ([
  str ('hello'),
  char (' '),
  str ('world')
]);

const parseResult = parse(parser)('hello world');

toPromise(parseResult)
  .catch(err =&gt; {
    // do something here with the error
  })
  .then(result =&gt; {
    // result -&gt; [ 'hello', ' ', 'world' ] 
  });
</code></pre>

<p>Or you can use <strong><em>toValue,</em></strong> which must be wrapped in a try/catch block:</p>

<pre><code class="javascript">const { parse, sequenceOf, str, char, toValue } = require('arcsecond');

const parser = sequenceOf ([
  str ('hello'),
  char (' '),
  str ('world')
]);

const parseResult = parse(parser)('hello world');

try {
  const result = toValue(parseResult);
  // -&gt; [ 'hello', ' ', 'world' ] 
} catch (err) {
  // do something with err
}
</code></pre>

<h3>Something more complex: JSON</h3>

<p>Let’s put <strong>arcsecond</strong> through its paces by using it to create a parser for JSON.</p>

<blockquote><p><a href="https://gist.github.com/francisrstokes/4d5f5b2de9644cf547799e3ac85fc6e2"><em>Click here to skip ahead and see the full JSON parser in one file</em></a></p></blockquote>

<h4>Values</h4>

<p>JSON only has 7 possible values:</p>

<ul>
<li>String</li>
<li>Number</li>
<li>true</li>
<li>false</li>
<li>null</li>
<li>Array</li>
<li>Object</li>
</ul>


<p>So to write a JSON parser, we just need to write parsers for all these values.</p>

<h4>Types</h4>

<p>In order for our parser to be useful we need to be able to identify what we’ve parsed, and the best way to do that is to put the results into a data type, which will provide a common interface for us to interact with the JSON tree. Every type has a <em>type</em> name, a <em>value</em>, and a <em>toString</em> function to pretty print the structure.</p>

<pre><code class="javascript">// Function to create a single-valued "type constructor"
const makeBasicType = typeName =&gt; value =&gt; ({
  type: typeName,
  value,
  toString: () =&gt; `${typeName}(${value})`
});

// Function to create a multi-valued "type constructor"
const makeMultiType = typeName =&gt; values =&gt; ({
  type: typeName,
  value: values,
  toString: () =&gt; `${typeName}(${values.map(v =&gt; v.toString()).join(', ')})`
});



const stringType = makeBasicType('String');
const numberType = makeBasicType('Number');
const booleanType = makeBasicType('Boolean');

const arrayType = makeMultiType('Array');
const objectType = makeMultiType('Object');

// For the object, we can store the key/value pairs in their own type
const keyValuePair = (key, value) =&gt; ({
  type: 'KeyValuePair',
  value: [key, value],
  toString: () =&gt; `KeyValuePair(${key.toString()}, ${value.toString()})`
});

const nullType = () =&gt; ({
  type: 'Null',
  value: null,
  toString: () =&gt; 'Null'
});



arrayType([
  stringType("hello"),
  numberType(42),
  stringType("world"),
  numberType(84),
]).toString();
// -&gt; Array(String(hello), Number(42), String(world), Number(84))
</code></pre>

<p>With our types in hand let’s start with the absolute simplest of parsers: <strong><em>true</em></strong>, <strong><em>false</em></strong> and <strong><em>null</em></strong>. These are just literal strings:</p>

<pre><code class="javascript">const { parse, str, choice } = require('arcsecond');

const nullParser = str ('null') .map(nullType);
const trueParser = str ('true') .map(booleanType);
const falseParser = str ('false') .map(booleanType);

const jsonParser = choice ([
  nullParser,
  trueParser,
  falseParser
]);
</code></pre>

<blockquote><p>The parsers in <strong>arcsecond</strong> have a <strong><em>map</em></strong> method — just like arrays —which allows you to transform the value the parser matched. With <strong><em>map</em></strong> we can put the values matched into the data types defined above.</p></blockquote>

<p>Numbers are a bit more complex. The <a href="https://json.org">JSON specification</a> has this railroad diagram showing how a number can be parsed:</p>

<p><img class="center" src="/images/json-number.gif" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The forks in the railroads show optionality, so the simplest number that can be matched is just 0.</p>

<p>Basically a numbers like:</p>

<ul>
<li><em>1</em></li>
<li><em>-0.2</em></li>
<li><em>3.42e2</em></li>
<li><em>-0.4352E-235</em></li>
</ul>


<p>Are all valid in JSON, while something like <em>03.46</em> is not, because no path in the railroad would allow for that.</p>

<pre><code class="javascript">const {
  choice,
  sequenceOf,
  char,
  digits,
  regex,
  possibly,
  anyOfString
} = require('arcsecond');

// The possibly parser either returns what it matches or null
// We can use the possibly parser to make one that returns empty string
// instead of null, which is more useful in this case
const orEmptyString = parser =&gt; possibly (parser) .map(x =&gt; (x) ? x : '');

// We also want to get sequences of matches, but then join them back
// together afterwards, instead of being in an array
const joinedSequence = parsers =&gt; sequenceOf (parsers) .map(x =&gt; x.join(''));

const numberParser = joinedSequence ([
  orEmptyString (char ('-')),
  choice ([
    char ('0'),
    regex (/^[1-9][0-9]*/)
  ]),
  orEmptyString (joinedSequence ([
    char ('.'),
    digits
  ])),
  orEmptyString (joinedSequence([
    anyOfString ('eE'),
    orEmptyString (anyOfString ('-+')),
    digits
  ]))
]) .map (x =&gt; numberType(Number(x)));


// Now we can add the numberParser to the jsonParser
const jsonParser = choice ([
  nullParser,
  trueParser,
  falseParser,
  numberParser
]);
</code></pre>

<p>If you take the time to read through the <strong><em>numberParser</em></strong>, you’ll see it lines up pretty much 1:1 with the diagram above.</p>

<p>Let’s try strings next. A string is anything between double quotes, but it can also contain escaped quotes.</p>

<pre><code class="javascript">const {
  between,
  many,
  choice,
  sequenceOf,
  char,
  anythingExcept
} = require('arcsecond');

// Like joinedSequence, we want to get many of the same matches and then join them
const joinedMany = parser =&gt; many (parser) .map(x =&gt; x.join(''));

const betweenQuotes = between (char ('"')) (char ('"'));

const stringParser = betweenQuotes (joinedMany (choice ([
  joinedSequence ([
    char ('\\'),
    char ('"')
  ]),
  anythingExcept (char ('"'))
]))) .map(stringType);

// Adding the stringParser to the jsonParser
const jsonParser = choice ([
  nullParser,
  trueParser,
  falseParser,
  numberParser,
  stringParser
]);
</code></pre>

<p>The <strong><em>anythingExcept</em></strong> parser comes in very handy here, and is especially expressive when compared with the image on the JSON spec website.</p>

<p><img class="center" src="/images/json-str.gif" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>That only leaves Array and Object, which can both be pitfalls because they are basically just containers of <strong><em>jsonValue.</em></strong> To illustrate how this might go wrong, we can write the Array parser the “wrong” way first and then see how to address it.</p>

<p>We can use the <strong><em>whitespace</em></strong> parser — which matches zero or more whitespace characters — to ensure the the array brackets and comma operator allow for any (optional) whitespace that might be there.</p>

<pre><code class="javascript">const {
  between,
  char,
  choice,
  sepBy,
  whitespace
} = require('arcsecond');

const whitespaceSurrounded = between (whitespace) (whitespace)
const betweenSquareBrackets = between (whitespaceSurrounded (char ('['))) (whitespaceSurrounded(char (']')));
const commaSeparated = sepBy (whitespaceSurrounded (char (',')));

const arrayParser = betweenSquareBrackets (commaSeparated (jsonParser)) .map(arrayType);

const jsonParser = choice ([
  nullParser,
  trueParser,
  falseParser,
  numberParser,
  stringParser,
  arrayParser
]);

// ReferenceError: jsonParser is not defined
</code></pre>

<p>Because <strong><em>arrayParser</em></strong> is defined in terms of <strong><em>jsonParser</em></strong>, and <strong><em>jsonParser</em></strong> is defined in terms of <strong><em>arrayParser</em></strong>, we run into a <em>ReferenceError</em>. If we moved the definition of <strong><em>arrayParser</em></strong> below <strong><em>jsonParser</em></strong>, we’d still have the same problem. We can fix this by wrapping the <strong><em>jsonParser</em></strong> in a special parser, aptly named <strong><em>recursiveParser</em></strong>. <a href="https://en.wikipedia.org/wiki/Thunk">The argument to <strong><em>recursiveParser</em></strong> is a thunk</a>, which will allow us to reference variables that are not yet in scope.</p>

<pre><code class="javascript">const {
  between,
  char,
  choice,
  sepBy,
  whitespace,
  recursiveParser
} = require('arcsecond');

const whitespaceSurrounded = between (whitespace) (whitespace)
const betweenSquareBrackets = between (whitespaceSurrounded (char ('['))) (whitespaceSurrounded(char (']')));
const commaSeparated = sepBy (whitespaceSurrounded (char (',')));

// Move this parser to the top, and wrap it in a recursiveParser,
// which takes a function that returns a parser
const jsonParser = recursiveParser (() =&gt; choice ([
  nullParser,
  trueParser,
  falseParser,
  numberParser,
  stringParser,
  arrayParser
]));

const arrayParser = betweenSquareBrackets (commaSeparated (jsonParser)) .map(arrayType);
</code></pre>

<p>Implementing the <strong><em>arrayParser</em></strong> is actually quite trivial — as simple as JSON values, separated by commas, in square brackets.</p>

<p>Object is only marginally more complex. The values in an object are pairs of strings some other JSON value, with a colon as a separator.</p>

<pre><code class="javascript">const {
  between,
  char,
  choice,
  sepBy,
  whitespace,
  recursiveParser
} = require('arcsecond');

const betweenCurlyBrackets = between (whitespaceSurrounded (char ('{'))) (whitespaceSurrounded(char ('}')));

const jsonParser = recursiveParser (() =&gt; choice ([
  nullParser,
  trueParser,
  falseParser,
  numberParser,
  stringParser,
  arrayParser,
  objectParser
]));

const keyValuePairParser = sequenceOf ([
  stringParser,
  whitespaceSurrounded (char (':')),
  jsonParser
]) .map(([key, _, value]) =&gt; keyValuePair(key, value));

const objectParser = betweenCurlyBrackets (commaSeparated (keyValuePairParser)) .map(objectType);
</code></pre>

<p>And that’s it. The <strong><em>jsonValue</em></strong> can be used to parse a JSON document in it’s entirety. <a href="https://gist.github.com/francisrstokes/4d5f5b2de9644cf547799e3ac85fc6e2">The full parser can be found here as a gist.</a></p>

<h3>Bonus Parser: CSV</h3>

<p>Since I opened up with a CSV parser in Haskell, let’s see how that would look in <strong>arcsecond</strong>. I’ll keep it minimal and forgo creating data types to hold the values, and some extra strengthening that the Parsec version also doesn’t have.</p>

<p>The result should be an array of arrays — the outer array holds “lines” and the inner arrays contain the elements of the line.</p>

<pre><code class="javascript">const {
  parse,
  char,
  many,
  regex,
  anythingExcept,
  sepBy
} = require('arcsecond');

const joinedMany = parser =&gt; many (parser) .map(x =&gt; x.join(''));

const cell = joinedMany (anythingExcept (regex (/^[,\n]/)));
const cells = sepBy (char (',')) (cell);
const parser = sepBy (char ('\n')) (cells);

const data = `
1,React JS,"A declarative efficient and flexible JavaScript library for building user interfaces"
2,Vue.js,"Vue.js is a progressive incrementally-adoptable JavaScript framework for building UI on the web."
3,Angular,"One framework. Mobile &amp; desktop."
4,ember.js,"Ember.js - A JavaScript framework for creating ambitious web applications"`;

console.log(
  parse (parser) (data)
);
// -&gt; [
//   [ '' ],
//   [ '1', 'React JS', '"A declarative efficient and flexible JavaScript library for building user interfaces"' ],
//   [ '2', 'Vue.js', '"Vue.js is a progressive incrementally-adoptable JavaScript framework for building UI on the web."' ],
//   [ '3', 'Angular', '"One framework. Mobile &amp; desktop."' ],
//   [ '4', 'ember.js', '"Ember.js - A JavaScript framework for creating ambitious web applications"' ],
// ]
</code></pre>

<h3>Conclusion</h3>

<p>There are quite a few key features of <strong>arcsecond</strong> that didn’t get a mention in this article, including the fact it <a href="https://en.wikipedia.org/wiki/Context-sensitive_grammar">can parse context sensitive languages</a>, and the parsing model is based on a <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land -compliant Monad</a>. My main goal with this project was to bring the same level of expressivity that Parsec has to JavaScript, and I hope I’ve been able to do that.</p>

<p><a href="https://github.com/francisrstokes/arcsecond">Please check out the project on github along with all the API docs and examples</a>, and think of <a href="https://github.com/francisrstokes/arcsecond"><strong>arcsecond</strong></a> the next time you find yourself writing an incomprehensible spaghetti regex — you might be using the wrong tool for the job! You can install the latest version with:</p>

<blockquote><p><strong>npm i arcsecond</strong></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Infinite Data Structures In JavaScript]]></title>
    <link href="http://francisrstokes.github.io/blog/blog/2019/01/07/infinite-data-structures-in-javascript/"/>
    <updated>2019-01-07T11:39:22+01:00</updated>
    <id>http://francisrstokes.github.io/blog/blog/2019/01/07/infinite-data-structures-in-javascript</id>
    <content type="html"><![CDATA[<p><em>Languages like Haskell are able to deal directly with Infinite Lists, but can that ability be brought to the world of JavaScript?</em></p>

<hr />

<p><img class="center" src="/images/inf-structure.png" width="600" height="600" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>In the real world we deal with “infinite” ideas all the time. All the positive numbers is an example of an infinite concept we wouldn’t bat an eye at. But typically when we are programming we have to think of these infinite concepts in a finite way. You can’t have an Array of all the positive numbers (at least not in JavaScript!).</p>

<p>What I want to introduce in this article is the idea of an <strong>Infinite List</strong> data structure, which can represent some never ending sequence, and let’s us use common operations like <strong><em>map</em></strong> and <strong><em>filter</em></strong> to modify and create new sequences.</p>

<pre><code class="javascript">const allPositiveNumbers = /* somehow we can create this */;

// We can create new Infinite structures using map and filter
const allEvenNumbers = allPositiveNumbers.filter(x =&gt; x % 2 === 0);
const allOddNumbers = allEvenNumbers.map(x =&gt; x - 1);
</code></pre>

<p>When we want to actually <em>use the data</em>, we can just <strong><em>take</em></strong> some concrete amount of it.</p>

<pre><code class="javascript">allPositiveNumbers.take(10);
// -&gt; [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

allEvenNumbers.take(10);
// -&gt; [ 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 ]

allOddNumbers.take(10);
// -&gt; [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 ]
</code></pre>

<h1>Creating an Infinite List</h1>

<p>To create the kind of structure defined above, we first need some way to just <em>describe</em> an infinite thing without needing to actually evaluate it (which would kill the computer <em>really fast</em>). To do that we first need to understand 2 things:</p>

<ul>
<li>The <em>iterator pattern</em></li>
<li><em>Generator</em> functions</li>
</ul>


<h2>The iterator pattern</h2>

<p>Let’s start with the <em>iterator pattern</em> first. The <em>iterator pattern</em> is a kind of design pattern where you can produce a lot of values, one at a time. It’s basically just an object with a <strong><em>.next()</em></strong> method. When that method is called, it returns another object with 2 keys: <strong><em>value</em></strong> and <strong><em>done</em></strong>. As we call <strong><em>.next()</em></strong>, the <strong><em>done</em></strong> property indicates whether the iterator has more values to give us, and the <strong><em>value</em></strong> is of course the value. Below is a simple iterator that returns values 0 to 3:</p>

<pre><code class="javascript">const createIterator = () =&gt; {
  let x = 0;
  return {
    next: () =&gt; {
      if (x &gt; 3) {
        return { value: undefined, done: true };
      } else {
        const currentValue = x;
        x += 1;
        return { value: currentValue, done: false }; 
      }
    }
  }
};

const iterator = createIterator();
iterator.next();
// -&gt; { value: 0, done: false }

iterator.next();
// -&gt; { value: 1, done: false }

iterator.next();
// -&gt; { value: 2, done: false }

iterator.next();
// -&gt; { value: 3, done: false }

iterator.next();
// -&gt; { value: undefined, done: true }
</code></pre>

<p>This kind of pattern has a <em>first-class</em> place in JavaScript. <strong><em>Arrays, Objects, Maps, and Sets</em></strong> can all implement the iterator pattern by conforming to an interface called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterables"><strong>Iterable</strong></a>.</p>

<h2>Generator functions</h2>

<p>Generator functions are a special kind of function in JavaScript which is declared with the <strong>function* syntax</strong>. Generator functions are used to create <em>iterator</em> objects (ones with a <strong><em>.next()</em></strong> method), but in much clearer and more concise way. Below is a finite generator that creates an equivalent iterator:</p>

<pre><code class="javascript">const createIterator = function* () {
  let x = 0;
  while (x &lt; 4) {
    yield x;
    x += 1;
  }
};
</code></pre>

<p>Here, the <strong><em>yield</em></strong> keyword is used to indicate the value that is returned every time the iterator is called. You can think of the function pausing after every yield, and picking up where it left off when the iterator’s <strong><em>.next()</em></strong> method is called again.</p>

<p>All it would take to make this an infinite generator is to turn the <strong><em>while (x &lt; 4)</em></strong> loop into a <strong><em>while (true)</em></strong> loop. For a better feel, here’s an infinite generator for the famous fibonacci sequence:</p>

<pre><code class="javascript">const createFibSeqIterator = function* () {
  let a = 0;
  let b = 1;
  while (true) {
    yield b;
    const tmp = a;
    a = b;
    b = b + tmp;
  }
};

const fibSeq = createFibSeqIterator();

fibSeq.next() // -&gt; { value: 1, done: false }
fibSeq.next() // -&gt; { value: 1, done: false }
fibSeq.next() // -&gt; { value: 2, done: false }
fibSeq.next() // -&gt; { value: 3, done: false }
fibSeq.next() // -&gt; { value: 5, done: false }
</code></pre>

<h2>Putting it together</h2>

<p>Iterators seem like a representation of something infinite because it lets us ask for the <strong><em>.next()</em></strong> element indefinitely. Furthermore, a generator seems like a good way to specify the iterator, because we can write succinct algorithms for infinite series without the boilerplate of manually crafting iterators.</p>

<p>But this still isn’t enough, because as powerful as generators are, they’re not really compositional. If I wanted to to create a generator where I filtered to all the fibonacci numbers that ended with a 5, I can’t easily use my existing createFibSeqIterator() to do that — i.e. I can’t compose the idea of the original generator + some new operation on it.</p>

<p>To remedy this, we first need to encapsulate the generator into a data type, which we can do with a class:</p>

<pre><code class="javascript">class Infinite {
  constructor (generatorFn) {
    this.generator = generatorFn;
  }
}
</code></pre>

<p>It’s on this class that we will implement our operations like <strong><em>filter</em></strong>, <strong><em>map</em></strong>, and <strong><em>take</em></strong>.</p>

<h2>Infinitely Lazy</h2>

<p>You might be puzzled when thinking about how we could implement an operation such as <strong><em>filter</em></strong>. The answer is <em>simple</em>: we do it lazily. Instead of actually trying to filter our list, we just make a note inside the <strong><em>Infinite</em></strong> class. Then when the user wants concretely <strong><em>.take()</em></strong> some elements of it, we can do the actual business of filtering then.</p>

<pre><code class="javascript">class Infinite {
  constructor (generatorFn) {
    this.generator = generatorFn;
    this.transformations = [];
  }

  filter(filterFn) {
    const newInfinite = new Infinite(this.generator);
    newInfinite.transformations = this.transformations.slice();
    newInfinite.transformations.push({
      type: 'filter',
      fn: filterFn
    });

    return newInfinite;
  }
}
</code></pre>

<p>The <strong><em>Infinite</em></strong> class gets a new <strong><em>transformations</em></strong> property, and <strong><em>filter</em></strong> creates a new Infinite with the same generator and transformations array, and pushes a transformation into the list.</p>

<p>We now have all the components we need now to write a <strong><em>.take()</em></strong> that will make the list concrete.</p>

<pre><code class="javascript">class Infinite {
  constructor (generatorFn) {
    this.generator = generatorFn;
    this.transformations = [];
  }

  filter(filterFn) {
    const newInfinite = new Infinite(this.generator);
    newInfinite.transformations = this.transformations.slice();
    newInfinite.transformations.push({
      type: 'filter',
      fn: filterFn
    });

    return newInfinite;
  }

  take(n) {
    const iterator = this.generator();
    const concrete = new Array(n);
    let index = 0;

    while (index &lt; n) {
      const {value, done} = iterator.next();

      if (done) {
        // The generator wasn't infinite, return what we got up until this point
        return concrete;
      }

      // Loop over the transformations and apply them to the value
      let x = value;
      let filtered = false;
      for (let i = 0; i &lt; this.transformations.length; i++) {
        const T = this.transformations[i];

        if (T.type === 'filter') {
          if (!T.fn(x)) {
            filtered = true;
          }
        }
      }

      // After the transformations are complete, if we didn't filter, then we can
      // x to the concrete list
      if (!filtered) {
        concrete[index] = x;
        index++;
      }
    }

    return concrete;
  }
}
</code></pre>

<p>When we call <strong><em>.take(n)</em></strong>, we can create an iterator out of the generator, and then initialize a fixed-length array with <strong><em>n</em></strong> elements. This will be our concrete list. An index variable can be used to keep track of how many concrete values we’ve collected so far. Using a while loop, we can get a value out of the iterator, and then run our list of transformations on it. If one of those transformations is a <strong><em>filter</em></strong>, and it doesn’t pass the test, we simply don’t add it to our concrete list, and repeat the loop. When we’ve collected <strong><em>n</em></strong> elements, we’re done and can return the concrete list.</p>

<p>Let’s see how that looks with the fibonacci example from before:</p>

<pre><code class="javascript">const fibonacciSequence = new Infinite(function* () {
  let a = 0;
  let b = 1;
  while (true) {
    yield b;
    const tmp = a;
    a = b;
    b = b + tmp;
  }
});

const fibsEndingWith5 = fibonacciSequence.filter(x =&gt; {
  const str = x.toString();
  return str[str.length - 1] === '5';
});

fibonacciSequence.take(5);
// -&gt; [ 1, 1, 2, 3, 5 ]

fibsEndingWith5.take(5);
// -&gt; [ 5, 55, 6765, 75025, 9227465 ]
</code></pre>

<p>To implement <strong><em>map</em></strong>, we could use much the same approach as with <strong><em>filter</em></strong>. The map method itself just clones the current <strong><em>Infinite</em></strong> and adds a new transformation to the list. Inside take, it’s enough to just add an <strong><em>else-if</em></strong> inside the transformation loop.</p>

<h2>Conclusion</h2>

<p>In this article we’ve explored the <em>iterator pattern</em> and <em>generator functions</em> in order to build a compositional and <em>lazily-evaluated</em> Infinite List data structure.</p>

<p>The <strong><em>Infinite</em></strong> List in this article is a bit limited however, because it lacks some operations that would make it truly useful, like a map implementation, dependent filtering, or the ability to combine Infinites together (like pairing every fibonacci number with a prime number, for example).</p>

<p>For these I created <em>lazy-infinite</em>, a more powerful <strong><em>Infinite List</em></strong> structure, that conforms to the <a href="https://github.com/fantasyland/fantasy-land">Fantasy-Land</a> specification. <a href="https://github.com/francisrstokes/Lazy-Infinite-List">I’d love for you to take a look on github</a>, or to give it a try in your next project with</p>

<p><em>npm i lazy-infinite</em></p>
]]></content>
  </entry>
  
</feed>
